data structures
---------------
	- the way in which the data is stored/organized
	
types
-----
	- linear data structures 
		- array, linked list
	- non-linear data structures
		- tree, heap, graph, trie
		
space complexity
time complexity
big O notation
--------------
O(1), O(n), O(n^2), O(logn), O(2^n), O(n!)



hashtable
---------
	- key value pair
	- constant time complexity when retrieving the value with the key
	- in our implemtation of hash table we will use an array to back the hashtable
	- when we insert data, we will specify the name of student as the key and the student object will be the value
	- The key can be of any data type. here we hash the key to an integer, now this integer will be one of the index of the array
	- internally, the array indices will be the key and the elements of the array will be the value
	
non- linear data structures
----------------------------
Tree
----
	- herirachical data structures
	- root node
	- parent node
	- child node
	- sibling nodes : nodes which have the same parent
	- leaf node : which do not have children
	- internal node : a node with atleast one child
	- external node : a node with no children
	- subtree
	- level
	- edge : connection between one node and another node
	- height of a node - the longest path from that node it its leaf node ( goes downwards)
	- depth of a node - how deep is the node from the root node - no of edges from that node to the root ( goes upwards)
	- height of the tree - height of the root node
	- path : a sequence of nodes and edges connecting a node with its descendant
	- descendant
	- ancestor
	
Binary Tree
-----------
	- a special tree with some rules
		- Every node can have 0 or 1 or 2 child nodes
		- the maximum number of children a node can have is 2
		- these children are called left node and right node
		- eg:
		
				25
			   /  \
			  23   12
			 /  \    \
			45  5     7
			
		- types of binary tree
			- complete binary tree
				- every level will have 2 children except the leaf nodes. the last level may or may not have 2 children.
				- in a complete binary tree all nodes have to be to the left as much possible
				- eg :
				
						25
					   /  \
					  23   12
					 /  \  / \
					45  5 8   89
				   /
				  21
			- full binary tree
				- a tree is considered a full binary binary tree if every node has exactly 0 or 2 children
				- eg: 
						25
					   /  \
					  23   12
					 /  \  / \
					45  5 8   89
							
Binary Search Tree(BST)(implementation)
---------------------------------------
	- main reason for BST to become popular is because insertion, deletion and retrievals can be done in O(logn).
	- also searching for an element in a unsorted list of data is faster. the time complexity is O(logn)
	- binary search timecomplexity + sorting time complexity is more that time complexity of retrieving a data from a BST
	- rules of BST
		- the left child node always has a value smaller than its parent
		- the right child node always has a value greater than the parent
		- in other words, everything on the left of the root is smaller than the root
		- likewise everything that is on the right of the root is greater than the root
	- insertion
	
	- traversal
		- 4 types of traversal
			- level traversal : not used much
			- pre-order traversal
				- visit the root of every subtree first
			- postorder traversal
				- visit the root of every subtree last
			- inorder traversal
				- visit left child, then parent , then right child
			eg:
			   
			   25
			   / \
			 20   27
			/ \   / \
		  15  22 26 30
		            / \
		           29 32
		           
		 level traversal 	 : 25, 20, 27, 15, 22, 26, 30, 29, 32
		 pre-order traversal : 25, 20, 15, 22, 27, 26, 30, 29, 32
		 post-order traversal: 15, 22, 20, 26, 29, 32, 30, 27, 25
		 in-order traversal  : 15, 20, 22, 25, 26, 27, 29, 30, 32 (data is automatically retrived in sorted order)
		 
	
	- min, max
	
	
	- delete
		- 3 cases
			1. the node is a leaf
				- very simple, just remove the node from the as it has no child nodes
			2. the node has one child
				- very simple, just replace the node with the deleted node's child
			3. the node has two children
				- need to figure out the replacement node
				- we want minimal disruption and preserve the structure of BST
				- we can take the replacement node from either the deleted nodes right subtree or left subtree
				- if you are taking from the left subtree, then take the largest value in the left subtree
				- if you are taking from the right subtree, then take smallest value in the right sub tree
				- choose one stick to it (any one)

Heap (implementation)
---------------------
	- has no relation to the heap memory that we talk about in object creation
	- heap is a special binary tree
	- properties
		1. It is a binary tree
		2. It is a complete binary tree
			- all levels are full except the last level
			- all nodes should be pushed to the leftmost side of the tree
		3. must satisfy heap property depending on whether it is max heap or a min heap
			- max heap
				- Every parent is greater than or equal to its children
			- min heap
				- Every parent is less than or equal to its children

	- how are we going to implement the heap? using array
	- eg: Max heap
	
				22
			   /  \
			 19   18
			/  \  / \ 
		   15  3 14  4
		  /
		 12  
	- we store the elements of the heap in an array
	- we put the root in array[0],
		0-22, 1-19, 2-18, 3-15, 4-3, 5- 14, 6-4, 7-12
		[22, 19, 18, 15, 3, 14, 4, 12]
	- if want to find the index of 
		left child -----> (2 * indexOfParent) + 1
		right child ----> (2 * indexOfParent) + 2
		parent ---------> floor((indexofChild - 1) / 2)
		
		right child of 18 with index 2 ------> (2 * 2) + 2 = 6th index
		left child of 15 with index 3 -----> (2 * 3) + 1 = 7th index
		parent of 3 with index 4 --------> (4-1)/2 = 1st index
		
	- insertion
		1. always add new item to the left of the heap
		2. then heapify above.
				heapify means fixing the heap
		
		- in the array, add the new item to the last index
		- compare this item with its parent
		- if it is greater than the parent, swap it
		- else leave it
		- keep doing this till you hit the root
		
	- deletion
		- must choose the replacement node
		- will take the rightmost value as the replacement node,so that the heap is complete binary tree
		- then we have to heapify the heap
		- when the replacement value is greater than parent - fix the heap above. Else fix the heap below
		- fix heap above : already did it for insert
		- fix heap below : 
				- swap the replacement value with the larger of its two children
				- repeat this until the replcement value is in its correct position
		- remember we have to only fix above or fix below
	
	- traversal
		- just print the array
	
	JDK implementation - PriorityQueue
	
Graph (implementation)
----------------------




	- traversal
		- for both the traversals we have to specify start vertex
		- for both the traversal we need a Set to keep track of the visited vertex
		- DFS
			- we need an additional Stack to store the adjacent vertex
		
		- BFS
			- we need an additional Queue to store the adjacent vertex
		

