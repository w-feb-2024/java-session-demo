ORM - Object Relational Mapping

- it is a concept
- has got nothing to do with spring framework for now
- this concept is applicable on the dao layer of the project


problems faced using vanilla jdbc
---------------------------------
- had to configure driver and connection and closing the connection
	- fix : use a datasource
- the select query returns a ResultSet
- we had to write native sql query
	- fix : go for ORM, we dont have to write any native sql query, but it also flexible
- writing complex joins in native SQL is difficult for java developers
	- fix : go for ORM


what exactly is ORM?
	- a concept
	- we map an entity class in java to a table in database 

what is JPA?
	- stands for Java Persistence API
	- a specification which is documented
	- more protocols/details are specified on the ORM concept 

what is Hibernate?
	- a implementation framework 
	- hibernate framework provides implementation on JPA specification - recomended ( beacause it will be easy to switch ORM framework later if required)
	- hibernate framework also provides implementation on Hibernate specification - not recomended
	- for now hibernate is a popular ORM framework

what is spring data JPA?
	- spring data JPA is a framework
	- and this framework wraps around hibernate framework, further making it easy for us to use hibernate framework
	- and it also provides the implementation code.
	- in this training we are working with spring Data JPA 


how do we do the mapping?
------------------------
	- we do the mapping witht he annotations, to be more specific it is jpa annotations
	

table : student_details
stud_id(P.K)
stud_name
stud_mark

@Entity  // this annotation tell the ORM framework that it is an entity - mandatory
@Table("student_details")  // this annotation maps the enitity class with a table in the DB - optional if table name and entity class name are the same
public class StudentEntity{
	
	@Id // mandatory as we have to tell the orm framework which is the primary key
	@Column("stud_id") // optional if column name and variable name are same
	private int studentId;

	@Column("stud_name")
	private String studentName;

	@Column("stud_mark")
	private String studentMark;
}


steps while working with spring data jpa
-----------------------------------------
	- create a new spring boot project using spring initializr
	- maven dependencies added
			- spring web
			- lombok
			- sql connector - driver
			- dev tool
			- swagger 2
			- validation
			- spring data jpa
	- import the project into eclipse
	- copy the files from controller, service, model package. no need to copy dao
	- start creating entity classes and map them using annotations to the table in the database
		- this is the only major work. properly and carefully map the entity classes.
	- create the BookDao interface and extend JpaRepository interface of spring framework.
	- there is no need to create and BookDaoImpl class
	- while doing so specify 2 generics - the Entity class and the data type of the primary key of the entity class
	- specify @Repository annotation above the BookDao interface
	- specify the datasource info and jpa info in application.properties file
		spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver
		spring.datasource.url=jdbc:mysql://localhost:3306/book_management_system
		spring.datasource.username=root
		spring.datasource.password=root
		
		spring.jpa.generate-ddl=true
		spring.jpa.show-sql=true
		spring.jpa.properties.hibernate.format_sql=true
		
		spring.jpa.database-platform=org.hibernate.dialect.MySQL8Dialect
		spring.jpa.hibernate.ddl-auto=validate
	- from the service layer call the predefined methods of the dao interface
	- start the spring boot project and test the endpoints through postman/swagger

relational/association mapping
------------------------------

one to one 
one to many
many to one
many to many

character_details - many, one
----------------
character_id(PK)
chararacter_first_name
character_last_name

book_details - one, many  ///  one, many
------------
book_id(PK)
book_title
author_id(FK)
book_genre
book_cost
book_published
book_image_url

author_details - one, one
--------------
author_id(PK)
auhtor_firt_name
author_last_name

from author_details to book_details it is one to many
from book_details to author_details it is many to one

	- the foreign key is on the many side

from book_details to character_details it is many to many
from character_details it will always be many to many

	- for a many to many relation we definetly need a third table to represent the relation
	- this third table will have a autogenerated primary key and foreign keys of both the table in relation
	
book_character_details
----------------------
book_char_id(PK)
book_id(FK)
character_id(FK)

ORM annotations used for relation mapping is
--------------------------------------------
@OneToOne
@OneToMany
@ManyToOne
@ManyToMany

@JoinColumn
@JoinTable 

how to use other sql queries other than the basic crud queries?
---------------------------------------------------------------
1. Query methods
	- here method name matters.
	- method name has to follow a particular sequence based on which the sql query is generated
		List<BookEntity> findByBookGenre(String genre);
	ref: https://docs.spring.io/spring-data/jpa/reference/jpa/query-methods.html
	
2. JPQL - Java Persistence Querying Language
	- here method name does not matter
	- we use @Query annotation above the method and provide JPQL
	- eg: 
	@Query("select b from BookEntity b where b.bookGenre=?1")
	List<BookEntity> getAllBooksByGenre(String genre);
	
		Native SQL - works on the table and column of the DB
		select * from book_details where book_genre="Commedy";
		
		JPQL - works on the entity class and its variables
		select b from BookEntity b where b.bookGenre="Commedy";
		
3. Named Queries
		ref : https://docs.spring.io/spring-data/jpa/docs/current-SNAPSHOT/reference/html/#reference
4. Native sql
	- here we use native sql instead of jpql
	@Query(name="select * from book_details where book_genre=?1", nativeQuery=true)
	List<BookEntity> getAllBooksByGenre(String genre);

